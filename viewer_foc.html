// ==================== ç„¦é»æ•™æç€è¦½å™¨æ ¸å¿ƒä»£ç¢¼ ====================

// æ ¹æ“šç•¶å‰é é¢ç²å–æ­£ç¢ºçš„è·¯å¾‘é…ç½®
const pathConfig = PathResolver.getBasePath();
const manifestURL = pathConfig.manifest;

let pdfList = [];
let currentIndex = -1;
let currentPage = 1;
let totalPages = 1;
let currentPDF = null;
let hasLikedCurrentPDF = false;

async function loadPDFList() {
  try {
    document.getElementById('statusText').innerHTML = '<span class="loading"></span>è¼‰å…¥æ•™ææ¸…å–®ä¸­...';
    
    console.log('æ­£åœ¨è¼‰å…¥ manifest:', manifestURL);
    
    const res = await fetch(manifestURL);
    if (!res.ok) {
      throw new Error(`HTTP ${res.status}: ${res.statusText}`);
    }
    
    const data = await res.json();
    if (!Array.isArray(data)) throw new Error('manifest.json æ‡‰ç‚ºé™£åˆ—æ ¼å¼');
    
    // ä¿®æ­£PDFè·¯å¾‘
    pdfList = data.map((item, index) => {
      const fixedUrl = PathResolver.fixPDFPath(item.url, pathConfig.pdfBase);
      console.log(`PDF ${index}: ${item.title} -> ${fixedUrl}`);
      
      return {
        ...item,
        url: fixedUrl,
        originalIndex: index
      };
    });
    
    console.log('è™•ç†å¾Œçš„PDFåˆ—è¡¨:', pdfList);
    
    // è¼‰å…¥æœ¬åœ°å„²å­˜çš„çµ±è¨ˆæ•¸æ“š
    loadLocalStats();

    const select = document.getElementById('pdfSelect');
    select.innerHTML = '';
    pdfList.forEach((item, index) => {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = `${index + 1}. ${item.title}`;
      select.appendChild(option);
    });

    if (pdfList.length > 0) {
      showPDF(0);
    } else {
      document.getElementById('statusText').textContent = 'âŒ æ²’æœ‰å¯ç”¨çš„æ•™æ';
    }
  } catch (err) {
    console.error('è¼‰å…¥éŒ¯èª¤ï¼š', err);
    document.getElementById('statusText').innerHTML = 
      `âŒ ç„¡æ³•è¼‰å…¥æ•™ææ¸…å–®: ${err.message}<br>
      <small>è«‹æª¢æŸ¥: ${manifestURL} æ˜¯å¦å­˜åœ¨</small>`;
  }
}

function loadLocalStats() {
  const stats = JSON.parse(localStorage.getItem(pathConfig.statsKey) || '{}');
  pdfList.forEach((item, index) => {
    if (stats[item.title]) {
      item.views = stats[item.title].views || 0;
      item.likes = stats[item.title].likes || 0;
    } else {
      item.views = 0;
      item.likes = 0;
    }
  });
}

function saveLocalStats() {
  const stats = {};
  pdfList.forEach(item => {
    stats[item.title] = {
      views: item.views || 0,
      likes: item.likes || 0,
      lastViewed: new Date().toISOString()
    };
  });
  localStorage.setItem(pathConfig.statsKey, JSON.stringify(stats));
}

function showPDF(index) {
  if (index < 0 || index >= pdfList.length) return;
  currentIndex = index;
  currentPage = 1;
  hasLikedCurrentPDF = false;

  const selectedItem = pdfList[index];
  const fileURL = selectedItem.url;
  
  console.log('å˜—è©¦è¼‰å…¥PDF:', fileURL);
  document.getElementById('statusText').innerHTML = '<span class="loading"></span>è¼‰å…¥æ•™æä¸­â€¦';

  pdfjsLib.getDocument(fileURL).promise.then(pdf => {
    currentPDF = pdf;
    totalPages = pdf.numPages;
    renderPage(currentPage);
    
    // æ›´æ–°è¨ªå•æ¬¡æ•¸
    pdfList[index].views = (pdfList[index].views || 0) + 1;
    saveLocalStats();
    updateStats(index);
    
    document.getElementById('statusText').textContent =
      `ğŸ“˜ ç•¶å‰æ•™æï¼š${selectedItem.title} (${index + 1}/${pdfList.length})`;
  }).catch(err => {
    console.error('PDF è¼‰å…¥å¤±æ•—ï¼š', err.message);
    document.getElementById('statusText').innerHTML = 
      `âŒ ç„¡æ³•é¡¯ç¤ºæ•™æï¼š${err.message}<br>
      <small>å˜—è©¦è·¯å¾‘: ${fileURL}</small>`;
  });

  document.getElementById('pdfSelect').value = index;
}

// å…¶é¤˜å‡½æ•¸ä¿æŒä¸è®Š